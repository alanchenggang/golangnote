#### Q1. RPC简介

> rpc，全称 remote process call（远程过程调用），是微服务架构下的一种通信模式. 这种通信模式下，一台服务器在调用远程机器的接口时，能够获得像调用本地方法一样的良好体验

![image-20230809150849207](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809150849207.png)



rpc 通常对标的是 restful 风格的 http 调用方式，下面开放地聊聊个人眼中 rpc 相较于 http 的优势所在：

>- rpc 调用基于 sdk 方式，调用方法和出入参协议固定，stub 文件本身还能起到接口文档的作用，很大程度上优化了通信双方约定协议达成共识的成本.
>- rpc 在传输层协议 tcp 基础之上，可以由实现框架自定义填充应用层协议细节，理论上存在着更高的上限

rpc 相较于 http 存在如下缺点：

>-  基于 sdk 方式调用，灵活度低、开发成本高，更多地适合用于系统内部模块间的通信交互，不适合对外
>- 用户自定义实现应用层协议，下限水平也很不稳定

grpc-go 以 HTTP2 作为应用层协议，使用 protobuf （下文可能简称 pb）作为数据序列化协议以及接口定义语言。

#### Q2. grpc定义服务

以下为简单的protobuf 文件

```protobuf
syntax = "proto3"; // 固定语法前缀


option go_package = "pb";  // 指定生成的Go代码在你项目中的导入路径


package pb; // 包名


// 定义服务
service HelloService {
  // SayHello 方法
  rpc SayHello (HelloReq) returns (HelloResp) {}
}


// 请求消息
message HelloReq {
  string name = 1;
}


// 响应消息
message HelloResp {
  string reply = 1;
}
```

抛开前置的固定语法标识外，分为三个核心部分：

- 定义业务处理服务 HelloService，声明业务方法的名称（SayHello）以及出入参协议（HelloReq/HelloResp）
- 遵循 protobuf 的风格，分别声明出入参的类型定义：HelloReq 和 HelloResp，其中分别包含了字符串类型的成员字段 name 和 reply

通过使用插件，可以在 .proto 文件基础上，一键生成对应的 go 代码.

```sh
protoc --go_out=. --go-grpc_out=. pb/hello.proto
```

>--go_out：指定 pb.go 文件的生成位置
>
>--go-grpc_out：指定 grpc.pb.go 文件的生成位置
>
>pb/hello.proto：这是指定了 .proto 文件的所在位置
>
>执行上述指令后，会生成 pb.go 和 grpc.pb.go 两个文件

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v4.23.2
// source: pb/hello.proto
// hello.pb.proto 文件内容
package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// 请求消息
type HelloReq struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *HelloReq) Reset() {
	*x = HelloReq{}
	if protoimpl.UnsafeEnabled {
		mi := &file_pb_hello_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HelloReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HelloReq) ProtoMessage() {}

func (x *HelloReq) ProtoReflect() protoreflect.Message {
	mi := &file_pb_hello_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HelloReq.ProtoReflect.Descriptor instead.
func (*HelloReq) Descriptor() ([]byte, []int) {
	return file_pb_hello_proto_rawDescGZIP(), []int{0}
}

func (x *HelloReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// 响应消息
type HelloResp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Reply string `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
}

func (x *HelloResp) Reset() {
	*x = HelloResp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_pb_hello_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HelloResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HelloResp) ProtoMessage() {}

func (x *HelloResp) ProtoReflect() protoreflect.Message {
	mi := &file_pb_hello_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HelloResp.ProtoReflect.Descriptor instead.
func (*HelloResp) Descriptor() ([]byte, []int) {
	return file_pb_hello_proto_rawDescGZIP(), []int{1}
}

func (x *HelloResp) GetReply() string {
	if x != nil {
		return x.Reply
	}
	return ""
}

var File_pb_hello_proto protoreflect.FileDescriptor

var file_pb_hello_proto_rawDesc = []byte{
	0x0a, 0x0e, 0x70, 0x62, 0x2f, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x02, 0x70, 0x62, 0x22, 0x1e, 0x0a, 0x08, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x71,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x22, 0x21, 0x0a, 0x09, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x73,
	0x70, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x32, 0x39, 0x0a, 0x0c, 0x48, 0x65, 0x6c, 0x6c, 0x6f,
	0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x29, 0x0a, 0x08, 0x53, 0x61, 0x79, 0x48, 0x65,
	0x6c, 0x6c, 0x6f, 0x12, 0x0c, 0x2e, 0x70, 0x62, 0x2e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65,
	0x71, 0x1a, 0x0d, 0x2e, 0x70, 0x62, 0x2e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x73, 0x70,
	0x22, 0x00, 0x42, 0x03, 0x5a, 0x01, 0x2e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_pb_hello_proto_rawDescOnce sync.Once
	file_pb_hello_proto_rawDescData = file_pb_hello_proto_rawDesc
)

func file_pb_hello_proto_rawDescGZIP() []byte {
	file_pb_hello_proto_rawDescOnce.Do(func() {
		file_pb_hello_proto_rawDescData = protoimpl.X.CompressGZIP(file_pb_hello_proto_rawDescData)
	})
	return file_pb_hello_proto_rawDescData
}

var file_pb_hello_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_pb_hello_proto_goTypes = []interface{}{
	(*HelloReq)(nil),  // 0: pb.HelloReq
	(*HelloResp)(nil), // 1: pb.HelloResp
}
var file_pb_hello_proto_depIdxs = []int32{
	0, // 0: pb.HelloService.SayHello:input_type -> pb.HelloReq
	1, // 1: pb.HelloService.SayHello:output_type -> pb.HelloResp
	1, // [1:2] is the sub-list for method output_type
	0, // [0:1] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_pb_hello_proto_init() }
func file_pb_hello_proto_init() {
	if File_pb_hello_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_pb_hello_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HelloReq); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_pb_hello_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HelloResp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_pb_hello_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_pb_hello_proto_goTypes,
		DependencyIndexes: file_pb_hello_proto_depIdxs,
		MessageInfos:      file_pb_hello_proto_msgTypes,
	}.Build()
	File_pb_hello_proto = out.File
	file_pb_hello_proto_rawDesc = nil
	file_pb_hello_proto_goTypes = nil
	file_pb_hello_proto_depIdxs = nil
}
```

上述代码展示了 pb.go 文件中的内容，核心是基于 .proto 定义的出入参协议，生成对应的 golang 类定义代码.

```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.23.2
// source: pb/hello.proto

// hello_grpc.pb.go 文件内容
package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// 基于 .proto 文件生成的客户端框架代码
// 客户端 interface
// HelloServiceClient is the client API for HelloService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HelloServiceClient interface {
	// SayHello 方法
	SayHello(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloResp, error)
}

// 客户端实现类
type helloServiceClient struct {
	cc grpc.ClientConnInterface
}

// 客户端构造器函数
func NewHelloServiceClient(cc grpc.ClientConnInterface) HelloServiceClient {
	return &helloServiceClient{cc}
}

// 客户端请求入口
func (c *helloServiceClient) SayHello(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloResp, error) {
	out := new(HelloResp)
	err := c.cc.Invoke(ctx, "/pb.HelloService/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}


// HelloServiceServer is the server API for HelloService service.
// All implementations must embed UnimplementedHelloServiceServer
// for forward compatibility
type HelloServiceServer interface {
	// SayHello 方法
	SayHello(context.Context, *HelloReq) (*HelloResp, error)
	mustEmbedUnimplementedHelloServiceServer()
}

// UnimplementedHelloServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHelloServiceServer struct {
}

func (UnimplementedHelloServiceServer) SayHello(context.Context, *HelloReq) (*HelloResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SayHello not implemented")
}
func (UnimplementedHelloServiceServer) mustEmbedUnimplementedHelloServiceServer() {}

// UnsafeHelloServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HelloServiceServer will
// result in compilation errors.
type UnsafeHelloServiceServer interface {
	mustEmbedUnimplementedHelloServiceServer()
}
// 服务端注册入口
func RegisterHelloServiceServer(s grpc.ServiceRegistrar, srv HelloServiceServer) {
	s.RegisterService(&HelloService_ServiceDesc, srv)
}

// 服务端业务方法框架代码
func _HelloService_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelloServiceServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.HelloService/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelloServiceServer).SayHello(ctx, req.(*HelloReq))
	}
	return interceptor(ctx, in, info, handler)
}

// HelloService_ServiceDesc is the grpc.ServiceDesc for HelloService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
// 服务端业务处理服务描述符
var HelloService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.HelloService",
	HandlerType: (*HelloServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _HelloService_SayHello_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/hello.proto",
}
```

上述代码展示了 grpc.pb.go 文件中的内容，核心内容包括：

-  基于 .proto 文件生成了客户端的桩代码，后续作为用户使用 grpc 客户端模块的 sdk 入口.

![image-20230809151500658](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809151500658.png)

- 基于 .proto 文件生成了服务端的服务注册桩代码，后续作为用户使用 grpc 服务端模块的 sdk 入口
- 基于 .proto 文件生成了业务处理服务（pb.HelloService）的描述符，每个描述符内部会建立基于方法名（SayHello）到具体处理函数（_HelloService_SayHello_Handler）的映射关系

#### Q3. 服务端!启动!

```go
package main

import (
	"context"
	"fmt"
	"google.golang.org/grpc"
	"grpc_go_hello/pb"
	"net"
)

// HelloService 业务处理服务
type HelloService struct {
	pb.UnimplementedHelloServiceServer
}

// SayHello 实现具体的业务方法逻辑
func (s *HelloService) SayHello(ctx context.Context, req *pb.HelloReq) (*pb.HelloResp, error) {
	return &pb.HelloResp{
		Reply: fmt.Sprintf("hello name: %s", req.Name),
	}, nil
}

func main() {
	// 创建 tcp 端口监听器
	listener, err := net.Listen("tcp", ":8093")
	if err != nil {
		panic(err)
	}
	// 创建 grpc server
	server := grpc.NewServer()
	// 将自定义的业务处理服务注册到 grpc server 中
	pb.RegisterHelloServiceServer(server, &HelloService{})
	// 将自定义的业务处理服务注册到 grpc server 中
	if err := server.Serve(listener); err != nil {
		panic(err)
	}
}
```

服务端启动流程
-  预声明业务处理服务 HelloService，实现好桩文件中定义的业务处理方法 SayHello
- 调用 net.Listen 方法，创建 tcp 端口监听器
- 调用 grpc.NewServer 方法，创建一个 grpc server 对象
- 调用桩文件中预生成好的注册方法 proto.RegisterHelloServiceServer，将 HelloService 注册到 grpc server 对象当中
- 运行 server.Serve 方法，监听指定的端口，真正启动 grpc server，

#### Q4. 客户端!启动!

```go
package main

import (
	"context"
	"fmt"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"grpc_go_hello/pb"
)

func main() {
	// 通过指定地址，建立与 grpc 服务端的连接
	conn, err := grpc.Dial(":8093", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		panic(err)
	}
	// 调用 .grpc.pb.go 文件中预生成好的客户端构造器方法，创建 grpc 客户端
	client := pb.NewHelloServiceClient(conn)
	// 调用 .grpc.pb.go 文件预生成好的客户端请求方法，使用 .pb.go 文件中预生成好的请求参数作为入参，向 grpc 服务端发起请求
	resp, err := client.SayHello(context.Background(), &pb.HelloReq{
		Name: "zhangbaolei",
	})
	if err != nil {
		panic(err)
	}
	fmt.Printf("resp: %+v", resp)

}
```

客户端代码中完成的核心步骤包括：

-  调用 grpc.Dial 方法，与指定地址的 grpc 服务端建立连接
-  调用桩文件中的方法 proto.NewHelloServiceClient，创建 pb 文件预声明好的 grpc 客户端对象
-   调用 client.SayHello 方法，发送 grpc 请求，并处理响应结果

#### Q4. 服务端原理解析

##### Q4.01 核心数据结构

在 grpc 服务端领域，自上而下有着三个层次分明的结构：server->service->method

-   最高级别是 server，是对整个 grpc 服务端的抽象
-   一个 server 下可以注册挂载多个业务服务 service
-   一个 service 下存在多个业务处理方法 method

![image-20230809154728762](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809154728762.png)

**（1）server**

```go
type Server struct {
    // 配置项
    opts serverOptions
    // 互斥锁保证并发安全
    mu  sync.Mutex 
    // tcp 端口监听器池
    lis map[net.Listener]bool
    // ...
    // 连接池
    conns    map[string]map[transport.ServerTransport]bool
    serve    bool
    cv       *sync.Cond          
    // 业务服务映射管理  
    services map[string]*serviceInfo // service name -> service info
    // ...
    serveWG            sync.WaitGroup 
    // ...
}
```

Server 类是对 grpc 服务端的代码实现，其中通过一个名为 services 的 map，记录了由服务名到具体业务服务模块的映射关系.

**（2）serviceInfo**

```go
type serviceInfo struct {
    // 业务服务类
	serviceImpl interface{}
    // 业务方法映射管理
	methods     map[string]*MethodDesc
    // ...
}
```

serviceInfo 是某一个具体的业务服务模块，其中通过一个名为 methods 的 map 记录了由方法名到具体方法的映射关系.

**（3）MethodDesc**

```go
type MethodDesc struct {
    MethodName string
    Handler    methodHandler
}
```

MethodDesc 是对方法的封装，其中的字段 Handler 是真正的业务处理方法

**（4）methodHandler**

```go
type methodHandler func(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor UnaryServerInterceptor) (interface{}, error)
```

methodsHandler 是业务处理方法的类型，其中几个关键入参的含义分别是：

-  srv：业务处理方法从属的业务服务模块
-   dec：进行入参 req 反序列化的闭包函数
-   interceptor：业务处理方法外部包裹的拦截器方法

##### Q4.02 创建 server

```go
// NewServer creates a gRPC server which has no service registered and has not
// started to accept requests yet.
func NewServer(opt ...ServerOption) *Server {
	opts := defaultServerOptions
	for _, o := range globalServerOptions {
		o.apply(&opts)
	}
	for _, o := range opt {
		o.apply(&opts)
	}
    //创建 server 实例
	s := &Server{
		lis:      make(map[net.Listener]bool),
		opts:     opts,
		conns:    make(map[string]map[transport.ServerTransport]bool),
		services: make(map[string]*serviceInfo),
		quit:     grpcsync.NewEvent(),
		done:     grpcsync.NewEvent(),
		czData:   new(channelzData),
	}
    // chainUnaryServerInterceptors 方法，将一系列拦截器 interceptor 成链，并注入到 ServerOption 当中
	chainUnaryServerInterceptors(s)
	chainStreamServerInterceptors(s)
	s.cv = sync.NewCond(&s.mu)
	if EnableTracing {
		_, file, line, _ := runtime.Caller(1)
		s.events = trace.NewEventLog("grpc.Server", fmt.Sprintf("%s:%d", file, line))
	}

	if s.opts.numServerWorkers > 0 {
		s.initServerWorkers()
	}

	s.channelzID = channelz.RegisterServer(&channelzServer{s}, "")
	channelz.Info(logger, s.channelzID, "Server created")
	return s
}


// chainUnaryServerInterceptors chains all unary server interceptors into one.
func chainUnaryServerInterceptors(s *Server) {
	// Prepend opts.unaryInt to the chaining interceptors if it exists, since unaryInt will
	// be executed before any other chained interceptors.
	interceptors := s.opts.chainUnaryInts
	if s.opts.unaryInt != nil {
		interceptors = append([]UnaryServerInterceptor{s.opts.unaryInt}, s.opts.chainUnaryInts...)
	}

	var chainedInt UnaryServerInterceptor
	if len(interceptors) == 0 {
		chainedInt = nil
	} else if len(interceptors) == 1 {
		chainedInt = interceptors[0]
	} else {
		chainedInt = chainUnaryInterceptors(interceptors)
	}

	s.opts.unaryInt = chainedInt
}
```

##### Q4.03 注册 service

![image-20230809155255550](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809155255550.png)

```go
// 将自定义的业务处理服务注册到 grpc server 中
	pb.RegisterHelloServiceServer(server, &HelloService{})


// 服务端注册入口
func RegisterHelloServiceServer(s grpc.ServiceRegistrar, srv HelloServiceServer) {
	s.RegisterService(&HelloService_ServiceDesc, srv)
}

//RegisterService向gRPCserver注册一个服务及其实现。它从IDL生成的代码中调用。这必须在调用Serve之前调用。如果ss为非nil(对于遗留代码)，则检查其类型以确保它实现sd.HandlerType。
func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
	if ss != nil {
		ht := reflect.TypeOf(sd.HandlerType).Elem()
		st := reflect.TypeOf(ss)
		if !st.Implements(ht) {
			logger.Fatalf("grpc: Server.RegisterService found the handler of type %v that does not satisfy %v", st, ht)
		}
	}
	s.register(sd, ss)
}


func (s *Server) register(sd *ServiceDesc, ss interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.printf("RegisterService(%q)", sd.ServiceName)
	if s.serve {
		logger.Fatalf("grpc: Server.RegisterService after Server.Serve for %q", sd.ServiceName)
	}
	if _, ok := s.services[sd.ServiceName]; ok {
		logger.Fatalf("grpc: Server.RegisterService found duplicate service registration for %q", sd.ServiceName)
	}
	info := &serviceInfo{
		serviceImpl: ss,
		methods:     make(map[string]*MethodDesc),
		streams:     make(map[string]*StreamDesc),
		mdata:       sd.Metadata,
	}
	for i := range sd.Methods {
		d := &sd.Methods[i]
		info.methods[d.MethodName] = d
	}
	for i := range sd.Streams {
		d := &sd.Streams[i]
		info.streams[d.StreamName] = d
	}
	s.services[sd.ServiceName] = info
}
```

> 注册过程会经历 RegisterHelloServiceServer->Server.RegisterService -> Server.register 的调用链路，把 service 的所有方法注册到 serviceInfo 的 methods map 当中，然后将 service 封装到 serviceInfo 实例中，注册到 server 的 services map 当中

##### Q4.04 运行 server

```go
func (s *Server) Serve(lis net.Listener) error {
    // ...


    var tempDelay time.Duration // how long to sleep on accept failure
    for {
        rawConn, err := lis.Accept()
        if err != nil {
            // ...
        }
        // ...
        s.serveWG.Add(1)
        go func() {
            s.handleRawConn(lis.Addr().String(), rawConn)
            s.serveWG.Done()
        }()
    }
}
```

![image-20230809155852063](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809155852063.png)

grpc server 运行的流程，核心是基于 for 循环实现的主动轮询模型，每轮会通过调用 net.Listener.Accept 方法，基于 IO 多路复用 epoll 方式，阻塞等待 grpc 请求的到达.

每当有新的连接到达后，服务端会开启一个 goroutine，调用对应的 Server.handleRawConn 方法对请求进行处理.

##### Q4.05 处理请求

![image-20230809160041990](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809160041990.png)

```go
func (s *Server) handleRawConn(lisAddr string, rawConn net.Conn) {
    // ...
    st := s.newHTTP2Transport(rawConn)
    // ...
    go func() {
        s.serveStreams(st)
        s.removeConn(lisAddr, st)
    }()
}

func (s *Server) serveStreams(st transport.ServerTransport) {
    var wg sync.WaitGroup

	// ...
    var roundRobinCounter uint32
    st.HandleStreams(func(stream *transport.Stream) {
        go func() {
            defer wg.Done()
            s.handleStream(st, stream, s.traceInfo(st, stream))
        }()
    }, func(ctx context.Context, method string) context.Context {
        // ...
    })
    wg.Wait()
}


func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {
    sm := stream.Method()
    // ...
    pos := strings.LastIndex(sm, "/")
    
    service := sm[:pos]
    method := sm[pos+1:]


    srv, knownService := s.services[service]
    if knownService {
        if md, ok := srv.methods[method]; ok {
            s.processUnaryRPC(t, stream, srv, md, trInfo)
            return
        }
        if sd, ok := srv.streams[method]; ok {
            s.processStreamingRPC(t, stream, srv, sd, trInfo)
            return
        }
    }
    // ...
}

func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, info *serviceInfo, md *MethodDesc, trInfo *traceInfo) (err error) {
    // ...
    d, err := recvAndDecompress(&parser{r: stream}, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp)
    // ...
    df := func(v interface{}) error {
        if err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != nil {
           // ...
        }
        // ...
    }
    ctx := NewContextWithServerTransportStream(stream.Context(), stream)
    reply, appErr := md.Handler(info.serviceImpl, ctx, df, s.opts.unaryInt)
    // ...


    if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil {
        // ...
    }
    // ...
}
```

![image-20230809160226360](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809160226360.png)建立了 Server.serveStreams -> http2Server.HandleStreams -> http2Server.operateHeaders -> http2Server.handleStream -> Server.processUnaryRPC 的方法调用链：

• 在 Server.handleStream 方法中，会拆解来自客户端的请求路径 ${service}/${method}，通过"/" 前段得到 service 名称，通过 "/" 后端得到 method 名称，并分别映射到对应的业务服务和业务方法

• 在 Server.processUnaryRPC 方法中，会通过 recvAndDecompress 读取到请求内容字节流，然后通过闭包函数 df 封装好反序列请求参数的逻辑，继而调用 md.Handler 方法处理请求，最终通过 Server.sendResponse 方法将响应结果进行返回

```go
func _HelloService_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(HelloReq)
    if err := dec(in); err != nil {
        return nil, err
    }
    if interceptor == nil {
        return srv.(HelloServiceServer).SayHello(ctx, in)
    }
    info := &grpc.UnaryServerInfo{
        Server:     srv,
        FullMethod: "/pb.HelloService/SayHello",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        return srv.(HelloServiceServer).SayHello(ctx, req.(*HelloReq))
    }
    return interceptor(ctx, in, info, handler)
}
```

客户端调用 SayHello 方法后，服务端对应的 md.Handler 正是 .proto 文件生成的位于 .grpc.pb.go 文件中的桩方法 _HelloService_SayHello_Handler.

在该桩方法内部中，包含的执行步骤如下：

-  调用闭包函数 dec，将请求内容反序列化到请求入参 in 当中
-  将业务处理方法 HelloServiceServer.SayHello 闭包封装到一个 UnaryHandler 当中
-  调用 intercetor 方法，分别执行拦截器和 handler 的处理逻辑

#### Q5. 拦截器

拦截器的作用，是在执行核心业务方法的前后，创造出一个统一的切片，来执行所有业务方法锁共有的通用逻辑. 此外，我们还能够通过这部分通用逻辑的执行结果，来判断是否需要熔断当前的执行链路，以起到所谓的”拦截“效果.

grpc 中对于一个拦截器函数的具体定义：

```go
type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)

• req：业务处理方法的请求参数
• info：当前所属的业务服务 service
• handler：真正的业务处理方法
```

简单拦截器示例

```go
var myInterceptor1 = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
    // 前处理校验
    if err := preLogicCheck();err != nil{
       // 前处理校验不通过，则拦截，不调用业务方法直接返回
       return nil,err 
    }
    
     // 前处理校验通过，正常调用业务方法
     resp, err = handle(ctx,req)
     if err != nil{
         return nil,err 
     }
     
      // 后置处理校验
      if err := postLogicCheck();err != nil{
         // 后置处理校验不通过，则拦截结果，包装错误返回
         return nil,err 
      }
      
      // 正常返回结果
      return resp,nil 
}
```

##### Q5.01  拦截器链

![image-20230809160801697](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809160801697.png)

```go
//  chainUnaryInterceptors 方法会将一系列拦截器 interceptor 成链，并返回首枚interceptor 供 ServerOption 接收设置.
func chainUnaryInterceptors(interceptors []UnaryServerInterceptor) UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (interface{}, error) {
        return interceptors[0](ctx, req, info, getChainUnaryHandler(interceptors, 0, info, handler))
    }
}

// 拦截器成链的关键在于 getChainUnaryHandler 方法中，其中会闭包调用拦截器数组的首枚拦截器函数，接下来依次用下一枚拦截器对业务方法 handler 进行包裹，封装成一个新的 ”handler“ 供当前拦截器使用.
func getChainUnaryHandler(interceptors []UnaryServerInterceptor, curr int, info *UnaryServerInfo, finalHandler UnaryHandler) UnaryHandler {
    if curr == len(interceptors)-1 {
        return finalHandler
    }
    return func(ctx context.Context, req interface{}) (interface{}, error) {
        return interceptors[curr+1](ctx, req, info, getChainUnaryHandler(interceptors, curr+1, info, finalHandler))
    }
}
```

![image-20230809160933105](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809160933105.png)

##### Q5.02 简单实践

```go
package main

import (
	"context"
	"fmt"
	"google.golang.org/grpc"
	"grpc_go_hello/pb"
	"net"
)

// HelloService 业务处理服务
type HelloService struct {
	pb.UnimplementedHelloServiceServer
}

// SayHello 实现具体的业务方法逻辑
func (s *HelloService) SayHello(ctx context.Context, req *pb.HelloReq) (*pb.HelloResp, error) {
	fmt.Println("core handle logic......")
	fmt.Printf("req: %+v\n", req)
	return &pb.HelloResp{
		Reply: fmt.Sprintf("hello name: %s", req.Name),
	}, nil
}

func main() {
	// 创建 tcp 端口监听器
	listener, err := net.Listen("tcp", ":8093")
	if err != nil {
		panic(err)
	}
	// 创建 grpc server
	server := grpc.NewServer(grpc.ChainUnaryInterceptor(myInterceptor1, myInterceptor2))
	// 将自定义的业务处理服务注册到 grpc server 中
	pb.RegisterHelloServiceServer(server, &HelloService{})
	// 将自定义的业务处理服务注册到 grpc server 中
	if err := server.Serve(listener); err != nil {
		panic(err)
	}
}

// 拦截器1
var myInterceptor1 = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
	fmt.Printf("interceptor1 preprocess, req: %+v\n", req)
	resp, err = handler(ctx, req)
	fmt.Printf("interceptor1 postprocess, req: %+v\n", resp)
	return
}

// 拦截器2
var myInterceptor2 = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
	fmt.Printf("interceptor2 preprocess, req: %+v\n", req)
	resp, err = handler(ctx, req)
	fmt.Printf("interceptor2 postprocess, resp: %+v\n", resp)
	return
}
```

![image-20230809161442648](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230809161442648.png)
