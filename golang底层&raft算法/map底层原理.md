#### Q1. map基本用法

##### Q1.01 概念

>map 又称字典，是一种常用的数据结构，核心特征包含下述三点：
>
>（1）存储基于 key-value 对映射的模式；
>
>（2）基于 key 维度实现存储数据的去重；
>
>（3）读、写、删操作控制，时间复杂度 O(1).

golang 中，对 map 的初始化分为以下几种方式：

```go
myMap1 := make(map[int]int,2)
```

```go
myMap2 := make(map[int]int)
```

```go
myMap3 :=map[int]int{
  1:2,
  3:4,
}
```

map 中，key 的数据类型必须为可比较的类型，chan、map、func不可比较



 读 map 分为下面两种方式：

```go
v1 := myMap[10]
```

第一种方式是直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底.

```go
v2,ok := myMap[10]
```

第二种方式是读的同时添加一个 bool 类型的 flag 标识是否读取成功. 倘若 ok == false，说明读取失败， key 不存在，或者 map 未初始化.

此处同一种语法能够实现不同返回值类型的适配，是由于代码在汇编时，会根据返回参数类型的区别，映射到不同的实现方法.

```go
myMap[5] = 6
```

写操作的语法如上. 须注意的一点是，倘若 map 未初始化，直接执行写操作会导致 panic：

```go
const plainError string
panic(plainError("assignment to entry in nil map"))
```

```go
delete(myMap,5)
```

执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示.

遍历分为下面两种方式：

```go
for k,v := range myMap{
  // ...
}
```

基于 k,v 依次承接 map 中的 key-value 对；

 

```go
for k := range myMap{
  // ...
}
```

基于 k 依次承接 map 中的 key，不关注 val 的取值.

需要注意的是，在执行 map 遍历操作时，获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异.

##### Q1.02 并发冲突(java hashmap?)

map 不是并发安全的数据结构，倘若存在并发读写行为，会抛出 fatal error.

具体规则是：

（1）并发读没有问题；

（2）并发读写中的“写”是广义上的，包含写入、更新、删除等操作；

（3）读的时候发现其他 goroutine 在并发写，抛出 fatal error；

（4）写的时候发现其他 goroutine 在并发写，抛出 fatal error.

```
fatal("concurrent map read and map write")
fatal("concurrent map writes")
```

需要关注，此处并发读写会引发 fatal error，是一种比 panic 更严重的错误，无法使用 recover 操作捕获.

#### Q2. 核心原理--- hash函数

map 又称为 hash map，在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储.

以一组 key-value 对写入 map 的流程为例进行简述：

（1）通过哈希方法取得 key 的 hash 值；

（2）hash 值对**桶数组**长度取模，确定其所属的桶；

（3）在桶中插入 key-value 对.

hash 的性质，保证了相同的 key 必然产生相同的 hash 值，因此能映射到相同的桶中，通过桶内遍历的方式锁定对应的 key-value 对.

因此，只要在宏观流程上，控制每个桶中 key-value 对的数量，就能保证 map 的几项操作都限制为常数级别的时间复杂度.

##### Q2.01 hash

hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程，由于这种转换属于压缩映射，输入空间远大于输出空间，因此不同输入可能会映射成相同的输出结果. 此外，hash在压缩过程中会存在部分信息的遗失，因此这种映射关系具有不可逆的特质.

（1）hash 的可重入性：相同的 key，必然产生相同的 hash 值；

（2）hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化；

![image-20230726123440064](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230726123440064.png)

（3）hash 的单向性：企图通过 hash 值反向映射回 key 是无迹可寻的.(单向性)

![image-20230726123459088](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230726123459088.png)

（4）hash 冲突：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突.

![image-20230726123525621](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230726123525621.png)

##### Q2.02 桶数组

map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：

（1）每个桶固定可以存放 8 个 key-value 对；

（2）倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题.

![image-20230726131634631](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230726131634631.png)

解决hash冲突的经典方法:拉链法(**链表**)/开放寻址法(**基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止**)

对标拉链还有开放寻址法，两者的优劣对比：

| **方法**   | **优点**                                                     |
| ---------- | ------------------------------------------------------------ |
| 拉链法     | 简单常用；无需预先为元素分配内存.                            |
| 开放寻址法 | 无需额外的指针用于链接元素；内存地址完全连续，可以基于局部性原理，充分利用 CPU 高速缓存. |

在 map 解决 hash /分桶 冲突问题时，实际上结合了拉链法和开放寻址法两种思路. 以 map 的插入写流程为例，进行思路阐述：

（1）桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联；

（2）每个桶固定可以存放 8 个 key-value 对；

（3）当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入；

（4）倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步；

（5）倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对.

##### Q2.03 扩容优化性能

倘若 map 的桶数组长度固定不变，那么随着 key-value 对数量的增长，当一个桶下挂载的 key-value 达到一定的量级，此时操作的时间复杂度会趋于线性，无法满足诉求.

因此在实现上，map 桶数组的长度会随着 key-value 对数量的变化而实时调整，以保证每个桶内的 key-value 对数量始终控制在常量级别，满足各项操作为 O(1) 时间复杂度的要求.

map 扩容机制的核心点包括：

（1）扩容分为增量扩容和等量扩容；

（2）当桶内 key-value 总数/桶数组长度 > 6.5 时发生增量扩容，桶数组长度增长为原值的两倍；

（3）当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值；

（4）采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动.

![image-20230726132349366](https://cscgblog-1301638685.cos.ap-chengdu.myqcloud.com/note/image-20230726132349366.png)