#### Q1. 线程与协程

> 线程是操作系统中的概念，是操作系统调度的基本单位。
>
> 每个线程都有自己的堆栈和寄存器等状态信息，线程之间的切换需要操作系统的介入。
>
> 线程的创建和销毁都需要操作系统的系统调用，因此线程的创建和销毁比较耗时。
>
> 线程之间的通信需要使用操作系统提供的同步原语，如锁、信号量等。

> 协程是一种轻量级的线程，也称为用户态线程。(与线程存在映射关系 为M:1)
>
> 协程的调度是由用户程序自己控制的，不需要操作系统的介入。
>
> 协程之间的切换是由程序自己控制的，因此切换的代价比线程小得多。
>
> 协程的创建和销毁都是由程序自己控制的，因此创建和销毁的代价也比线程小得多。
>
> 协程之间的通信可以使用共享内存或消息传递等方式。

#### Q2. goroutine 简介

```go
goroutine` 是 Go 语言中的轻量级线程，它由 Go 运行时环境管理。`goroutine` 可以在单个线程上运行，因此创建和销毁 `goroutine` 的成本很低。Go 语言的并发模型是基于 `goroutine` 和通道（channel）的，这使得编写并发程序变得更加容易和直观。在 Go 语言中，可以使用 `go` 关键字来启动一个新的 `goroutine
```

#### Q3. 三种模型对比

| 模型      | 弱依赖内核 | 可并行 | 可应对阻塞 | 栈可动态扩缩 |
| --------- | ---------- | ------ | ---------- | ------------ |
| 线程      | N          | Y      | Y          | N            |
| 协程      | Y          | N      | N          | N            |
| goroutine | Y          | Y      | Y          | Y            |

#### Q4. gmp 理论模型

g-->goroutine

> golang中对协程的抽象
>
> 每个都有自己的运行栈&状态&执行的任务函数
>
> g需要绑定到p才能执行，在g的视角看来 p=== cpu

m-->machine

>golang中线程的抽象
>
>m不直接执行g，而是先和p绑定，由其实现代理
>
>因为p的存在，m无需和g绑定，也无需记录g的状态信息，因此g在全生命周期中可以实现跨m执行

p -->processor

> golang中的调度器
>
> gmp的中枢，实现g到m之间的动态结合
>
> 对g而言 p是cpu/对m而言 p是其执行代理，为其提供必要信息的同时隐藏了复杂的调度细节
>
> p的数量决定了g最大并行数量

#### Q5. gmp 数据结构



#### Q6.协程状态转换/调度类型



#### Q7.获取可执行的 g 的方法



#### Q8. 调度器的 work-stealing 机制



#### Q9. 执行 goroutine 逻辑



#### Q10. 主动让渡与被动阻塞/调度结束与抢占调度









